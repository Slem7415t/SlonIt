# <img src="images/logo.jpg" alt="logo" width="80"/> $${\color{red}Git\ \color{orange}-\ система\ контроля\ версий(хранилище\ истории\ проекта).}$$

[add |](#colordaa520добавление-файла-в-директорию-index)
[commit |](#colordaa520добавление-файла-в-repository)
[удаление |](#colordaa520удаление)
[переименование |](#colordaa520переименование)
[алиасы |](#colordaa520алиасы---позволяют-делать-заготовки-команд-чтобы-не-писать-их-каждый-раз)
[gitignore](#colordaa520gitignore)

---

## ${\color{#DAA520}Создание\ репозитория}$
`$ git init` - создаём репозиторий (папку с git), создавать ее нужно в корне проекта.

## ${\color{#DAA520}Создание,\ редактирование\ и\ удаление\ автора\ и\ почты\ проекта}$
`$ git config user.name "имя_пользователя"`   
`$ git config user.email почта`   
\- команды указывают автора и почту для созданного репозитория, если указать флаг ***--global***, то в новых проектах почта и имя будут устанавливаться автоматически при создании.   
`$ git config --global user.name "имя_пользователя"`   
`$ git config --global user.email почта`   

**Директории бывают 3х видов:**  
\- системные (*--system*)    
\- глобальные (*--global*)   
\- локальные (*--local*)     
git сначала ищет в локальной директории, затем если не нашел в глобальной и если и там нет, то уже в системной.

**команды:**    
`$ git config --unset user.name`    
`$ git config --unset user.email`  
\- удалят локальные автора и почту.

Можно выполнить операцию одной командой вместо двух, которая удалит всю директорию ***user***.     
`$ git config --remove-section user`

Также можно открыть файл ***config*** в текстовом редакторе и отредактировать на его прямую.

`$ git commit --author='имя_автора <почта>' --date='дата'` - меняет автора(кто создал commit) и время создания commit, но не создателя(кто добавил commit в репозиторий). С помощью другой команды можно поменять и его.

## ${\color{#DAA520}Текстовый\ редактор}$
Команда `$ git config --global core.editor путь_к_файлу флаги(если нужны)`  - позволяет установить или поменять текстовый редактор для git.

## ${\color{#DAA520}АЛИАСЫ\ -\ позволяют\ делать\ заготовки\ команд,\ чтобы\ не\ писать\ их\ каждый\ раз}$
`$ git config --global alias.c config` - создаст алиас ***с*** вместо ***config***.     
`$ git config --global alias.sayhi '!echo "hello"; echo "from git"'` - алиас ***sayhi*** будет вызывать сразу две команды.

## ${\color{#DAA520}Help}$
`$ git config ~h` - вызывает список команд.     
`$ git help имя_команды` - вызывает опции команды.

В поиске листалки:  
- `/слово` -поиск нужного слова
- `n` - поиск в верх
- `shift+n` - поиск в низ
- `q` - выход

## ${\color{#DAA520}Статус\ проекта}$
`$ git status` - выводит информацию о файлах проекта.  
Команда `$ git show --prett=fuller индификатор(или его начало не менее 4х символов)` - выводит информацию о commit(можно без флага, будет меньше информации).

## ${\color{#DAA520}Добавление\ файла\ в\ директорию\ index}$
`$ git add имя_файла` - добавляет файл в отслеживаемые файлы(директория ***index***).     
`$ git add .` - добавляет все.     
`$ git add -p название_файла` - позволяет выборочно добавлять разные куски кода из файла.
`$ git reset HEAD название_папки_или_файла` - отменяет изменения для указанного каталога(выводит его из ***index**).

## ${\color{#DAA520}Добавление\ файла\ в\ Repository}$
`$ git commit` - добавляет файл в историю проекта(директория ***Repository***, где храниться вся история проекта).         
Проекту заранее должны быть присвоены ***автор*** и ***почта*** или commit не сработает.    
Далее нас перебросит в редактор, где нужно указать ***название commit***(можно сделать комментарий, оставив пустую строку после названия и после звездочки в каждой строке, написать комментарий к нему).         
`$ git commit -m 'имя_commit'` - позволяет без редактора добавить commit.  
`$ git commit -am 'имя_commit'` - сразу запишет commit в репозиторий без ***add***, но он игнорирует не отслеживаемые файлы.  
`$ git commit -m 'имя_commit' путь` - сразу закомитит файлы без ***add***, но только по указанному пути. Но тоже только проиндексированные(отслеживаемые) файлы.

## ${\color{#DAA520}Исполнимые\ и\ не\ исполнимые\ файлы}$
Файл может иметь разные ***права*** и быть ***исполнимым*** или ***нет***. Число перед именем закомиченного файла 100644 означает(100 - что тип файл, 644 - что он не исполнимый, у исполнимого 755).     
На windows команды:     
`chmod +x имя_файла` - делает его исполнимым.    
`chmod -x имя_файла` - делает его не исполнимым.

## ${\color{#DAA520}.gitignore}$
Файл `.gitignore` - создаем в корне проекта и туда добавляем (каждое с новой строки) названия папок и файлов, которые нужно игнорировать.   
`$ git add -f имя_файла_или_папки` - добавляет принудительно игнорируемый файл.    
Если написать `*.расширение_файла` - git будет игнорировать все файлы с данным расширением.        
`$ git config --global core.excludasFile ~/.gitignore` - создаст глобальный игнор файл.

## ${\color{#DAA520}ХОРОШИЙ\ COMMIT\ -\ атомарный\ и\ логически\ завершенный}$
Должен быть не большим на какую-нибудь одну функциональность.

**Виды оформления заголовков:**
1. Заголовок с должен быть с большой буквы, в конце не ставится точка.
2. компонент: над_чем_работали описание
3. характер работы(компонент над которым работали): детали

## ${\color{#DAA520}Удаление}$
После удаления файла команда `$ git add имя_файла` - удалит его из директории ***index***, затем командой
`$ git commit -m Cleanup` - фиксируем изменения в директории ***Repository***.     
`$ git rm путь` - для удалении файла по пути.      
`$ git -r имя_папки`> - для удаления директории, ***add*** в том случае не нужно.     
`$ git -r --cached имя_папки` - удалит только из ***index***.    
Флаг `--cached` - используется и в других командах, где требуются операции только с ***index***.     
`$ git rm -f имя_файла` - удалит не закомиченный файл, без предупреждения.

## ${\color{#DAA520}Переименование}$
При переименовании файла git воспринимает операцию как: ***удаление*** одного файла и ***создание*** нового файла. Только после ***add***, он понимает что произошло переименование.            
Затем мы все ровно делаем ***commit***, чтобы зафиксировать изменение в репозиторий.        
`$ git mv старое_имя_файла новое_имя_файла` - переименовывает в одну команду (***add*** + ***commit***).

## ${\color{#DAA520}Создание\ ветки}$
`$ git branch` - просмотр веток.     
`$ git branch -v` - просмотр веток с информацией.
В папке ***git*** файл ***HEAD*** хранит ссылку на текущую ветку.

`$ git branch название_ветки` - создаст новую ветку. Ветки хранятся по адресу: ***.git / refs / heads***.

## ${\color{#DAA520}Переключение\ ветки}$
`$ git checkout название_ветки` - переключение на другую ветку.     
`$ git checkout -f название_ветки` - принудительное переключение на другую ветку. При этом если в одинаковые файлы имеют разный код, то несохраненные изменения из предыдущей ветки не сохранятся.      
`$ git checkout -f HEAD` - отменит все несохраненные изменения(можно использовать без ***HEAD***).

`$ git stash` - архивирует незакомиченные изменения, чтобы можно было переключиться на другую ветку.        
`$ git stash pop` - возвращает заархивированные изменения, используется после возврата в ветку.

`$ git checkout -b название_ветки` - создаст новую ветку и сразу переключится на неё(ключ ***-b*** - создать и переключить). Команда используется для переноса незакомиченных изменений в другую ветку в том же ***commit***. После того как изменения будут закомиченны, новую ветку можно использовать независимо от старой ветки.

## ${\color{#DAA520}Перенос\ commit}$
Для переноса ***commit*** в другую ветку, создаем ветку командой `$ git branch название_ветки`, затем перекачаемся на неё и вводим команду `$ git branch название_ветки_в_которой_commit индификатор_commit_на_который_она_должна_передвинутся` - старая ветка откатится к указанному ***commit***, а последующие ***commit*** останутся в новой ветке(для принудительности использовать флаг ***-f***)     
Чтобы все вернуть назад команда `$ git branch название_ветки_что_передвинули название_ветки_где_остались_commit`.

## ${\color{#DAA520}Отделенный\ HEAD}$
`$ git checkout индификатор_commit` - переносит ***HEAD*** на указанный ***commit***, но при этом отделяет его от ветки. Нужно быть осторожным с этим состоянием так как git, со временем удаляет ***commit*** без ветки.

`$ git cherry-pick индификатор_commit` - сохраняет ***commit*** без ветки на текущую ветку.

## ${\color{#DAA520}Восстановление\ предыдущих\ версий\ файлов}$
`$ git checkout индификатор_commit путь_к_файлу` - вернут файл из ***Repository*** в ***index*** и рабочую область(не отслеживаемые файлы).     
`$ git reset путь_к_файлу` - уберут его из ***index***, оставив его только в рабочей области(не отслеживаемые файлы).

## ${\color{#DAA520}Просмотр\ истории\ и\ файлов}$
`$ git log` - показывает историю ***commit***.      
`$ git log` - показывает компактный вариант истории ***commit***.       
`$ git log название_ветки --oneline` - показывает историю определенного ***commit***.

`$ git show индификатор_commit` - посмотреть ***commit*** подробно.     
`$ git show HEAD_или_индификатор_commit` - информация о ***commit***(если ***HEAD*** то текущего).      
Можно использовать ключ ***--quiet*** для краткости.        
После ***HEAD_или_индификатор_commit*** `~` переносит на 1 уровень вниз к родителю от указанного ***commit***. Будет переносить по количеству ***~***(вместо ***~~~*** можно ***~3***).      
***HEAD*** - можно заменить на ***@***.

`$ git show @~:путь_к_файлу` - позволит посмотреть файл из ***commit*** родителя.       
`$ git show :что_искать` - поиск по слову.

---
Документация к [Markdown](https://gist.github.com/Jekins/2bf2d0638163f1294637)